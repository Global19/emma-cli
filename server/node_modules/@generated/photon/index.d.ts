import { DMMF, DMMFClass, Engine } from './runtime'
/**
 * Utility Types
 */
export declare type Enumerable<T> = T | Array<T>
export declare type MergeTruthyValues<R extends object, S extends object> = {
  [key in keyof S | keyof R]: key extends false
    ? never
    : key extends keyof S
    ? S[key] extends false
      ? never
      : S[key]
    : key extends keyof R
    ? R[key]
    : never
}
export declare type CleanupNever<T> = {
  [key in keyof T]: T[key] extends never ? never : key
}[keyof T]
/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
}
declare class PhotonFetcher {
  private readonly photon
  private readonly engine
  private readonly debug
  private readonly hooks?
  constructor(
    photon: Photon,
    engine: Engine,
    debug?: boolean,
    hooks?: Hooks | undefined,
  )
  request<T>(
    document: any,
    path?: string[],
    rootField?: string,
    typeName?: string,
    isList?: boolean,
    callsite?: string,
  ): Promise<T>
  protected unpack(
    document: any,
    data: any,
    path: string[],
    rootField?: string,
    isList?: boolean,
  ): any
}
/**
 * Client
 **/
export declare type Datasources = {
  pg?: string
}
export interface PhotonOptions {
  datasources?: Datasources
  debug?:
    | boolean
    | {
        engine?: boolean
        library?: boolean
      }
  /**
   * You probably don't want to use this. `__internal` is used by internal tooling.
   */
  __internal?: {
    hooks?: Hooks
    engine?: {
      cwd?: string
      binaryPath?: string
    }
  }
}
export declare type Hooks = {
  beforeRequest?: (options: {
    query: string
    path: string[]
    rootField?: string
    typeName?: string
    document: any
  }) => any
}
export declare class Photon {
  private fetcher
  private readonly dmmf
  private readonly engine
  private readonly datamodel
  private connectionPromise?
  constructor(options?: PhotonOptions)
  private connectEngine
  connect(): Promise<void>
  disconnect(): Promise<void>
  readonly starters: StarterDelegate
}
export declare const OrderByArg: {
  asc: 'asc'
  desc: 'desc'
}
export declare type OrderByArg = (typeof OrderByArg)[keyof typeof OrderByArg]
/**
 * Model Starter
 */
export declare type Starter = {
  id: string
  createdAt: Date
  updatedAt: Date
  repo: string
  owner: string
  path: string
  ref: string
  name: string
  description: string | null
  dependencies: string[]
}
export declare type StarterScalars =
  | 'id'
  | 'createdAt'
  | 'updatedAt'
  | 'repo'
  | 'owner'
  | 'path'
  | 'ref'
  | 'name'
  | 'description'
  | 'dependencies'
export declare type StarterSelect = {
  id?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  repo?: boolean
  owner?: boolean
  path?: boolean
  ref?: boolean
  name?: boolean
  description?: boolean
  dependencies?: boolean
}
export declare type StarterInclude = {}
declare type StarterDefault = {
  id: true
  createdAt: true
  updatedAt: true
  repo: true
  owner: true
  path: true
  ref: true
  name: true
  description: true
  dependencies: true
}
declare type StarterGetSelectPayload<
  S extends boolean | StarterSelect
> = S extends true
  ? Starter
  : S extends StarterSelect
  ? {
      [P in CleanupNever<MergeTruthyValues<{}, S>>]: P extends StarterScalars
        ? Starter[P]
        : never
    }
  : never
declare type StarterGetIncludePayload<
  S extends boolean | StarterInclude
> = S extends true
  ? Starter
  : S extends StarterInclude
  ? {
      [P in CleanupNever<
        MergeTruthyValues<StarterDefault, S>
      >]: P extends StarterScalars ? Starter[P] : never
    }
  : never
export interface StarterDelegate {
  <T extends FindManyStarterArgs>(
    args?: Subset<T, FindManyStarterArgs>,
  ): T extends FindManyStarterArgsRequired
    ? 'Please either choose `select` or `include`'
    : T extends FindManyStarterSelectArgs
    ? Promise<
        Array<StarterGetSelectPayload<ExtractFindManyStarterSelectArgs<T>>>
      >
    : T extends FindManyStarterIncludeArgs
    ? Promise<
        Array<StarterGetIncludePayload<ExtractFindManyStarterIncludeArgs<T>>>
      >
    : Promise<Array<Starter>>
  findOne<T extends FindOneStarterArgs>(
    args: Subset<T, FindOneStarterArgs>,
  ): T extends FindOneStarterArgsRequired
    ? 'Please either choose `select` or `include`'
    : T extends FindOneStarterSelectArgs
    ? Promise<StarterGetSelectPayload<
        ExtractFindOneStarterSelectArgs<T>
      > | null>
    : T extends FindOneStarterIncludeArgs
    ? Promise<StarterGetIncludePayload<
        ExtractFindOneStarterIncludeArgs<T>
      > | null>
    : StarterClient<Starter | null>
  findMany<T extends FindManyStarterArgs>(
    args?: Subset<T, FindManyStarterArgs>,
  ): T extends FindManyStarterArgsRequired
    ? 'Please either choose `select` or `include`'
    : T extends FindManyStarterSelectArgs
    ? Promise<
        Array<StarterGetSelectPayload<ExtractFindManyStarterSelectArgs<T>>>
      >
    : T extends FindManyStarterIncludeArgs
    ? Promise<
        Array<StarterGetIncludePayload<ExtractFindManyStarterIncludeArgs<T>>>
      >
    : Promise<Array<Starter>>
  create<T extends StarterCreateArgs>(
    args: Subset<T, StarterCreateArgs>,
  ): T extends StarterCreateArgsRequired
    ? 'Please either choose `select` or `include`'
    : T extends StarterSelectCreateArgs
    ? Promise<StarterGetSelectPayload<ExtractStarterSelectCreateArgs<T>>>
    : T extends StarterIncludeCreateArgs
    ? Promise<StarterGetIncludePayload<ExtractStarterIncludeCreateArgs<T>>>
    : StarterClient<Starter>
  delete<T extends StarterDeleteArgs>(
    args: Subset<T, StarterDeleteArgs>,
  ): T extends StarterDeleteArgsRequired
    ? 'Please either choose `select` or `include`'
    : T extends StarterSelectDeleteArgs
    ? Promise<StarterGetSelectPayload<ExtractStarterSelectDeleteArgs<T>>>
    : T extends StarterIncludeDeleteArgs
    ? Promise<StarterGetIncludePayload<ExtractStarterIncludeDeleteArgs<T>>>
    : StarterClient<Starter>
  update<T extends StarterUpdateArgs>(
    args: Subset<T, StarterUpdateArgs>,
  ): T extends StarterUpdateArgsRequired
    ? 'Please either choose `select` or `include`'
    : T extends StarterSelectUpdateArgs
    ? Promise<StarterGetSelectPayload<ExtractStarterSelectUpdateArgs<T>>>
    : T extends StarterIncludeUpdateArgs
    ? Promise<StarterGetIncludePayload<ExtractStarterIncludeUpdateArgs<T>>>
    : StarterClient<Starter>
  deleteMany<T extends StarterDeleteManyArgs>(
    args: Subset<T, StarterDeleteManyArgs>,
  ): Promise<BatchPayload>
  updateMany<T extends StarterUpdateManyArgs>(
    args: Subset<T, StarterUpdateManyArgs>,
  ): Promise<BatchPayload>
  upsert<T extends StarterUpsertArgs>(
    args: Subset<T, StarterUpsertArgs>,
  ): T extends StarterUpsertArgsRequired
    ? 'Please either choose `select` or `include`'
    : T extends StarterSelectUpsertArgs
    ? Promise<StarterGetSelectPayload<ExtractStarterSelectUpsertArgs<T>>>
    : T extends StarterIncludeUpsertArgs
    ? Promise<StarterGetIncludePayload<ExtractStarterIncludeUpsertArgs<T>>>
    : StarterClient<Starter>
  count(): Promise<number>
}
export declare class StarterClient<T> implements Promise<T> {
  private readonly _dmmf
  private readonly _fetcher
  private readonly _queryType
  private readonly _rootField
  private readonly _clientMethod
  private readonly _args
  private readonly _path
  private _isList
  private _callsite
  private _requestPromise?
  constructor(
    _dmmf: DMMFClass,
    _fetcher: PhotonFetcher,
    _queryType: 'query' | 'mutation',
    _rootField: string,
    _clientMethod: string,
    _args: any,
    _path: string[],
    _isList?: boolean,
  )
  readonly [Symbol.toStringTag]: 'PhotonPromise'
  private readonly _document
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?:
      | ((value: T) => TResult1 | Promise<TResult1>)
      | undefined
      | null,
    onrejected?:
      | ((reason: any) => TResult2 | Promise<TResult2>)
      | undefined
      | null,
  ): Promise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?:
      | ((reason: any) => TResult | Promise<TResult>)
      | undefined
      | null,
  ): Promise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>
}
/**
 * Starter findOne
 */
export declare type FindOneStarterArgs = {
  select?: StarterSelect | null
  include?: StarterInclude | null
  where: StarterWhereUniqueInput
}
export declare type FindOneStarterArgsRequired = {
  select: StarterSelect
  include: StarterInclude
  where: StarterWhereUniqueInput
}
export declare type FindOneStarterSelectArgs = {
  select: StarterSelect
  where: StarterWhereUniqueInput
}
export declare type FindOneStarterSelectArgsOptional = {
  select?: StarterSelect | null
  where: StarterWhereUniqueInput
}
export declare type FindOneStarterIncludeArgs = {
  include: StarterInclude
  where: StarterWhereUniqueInput
}
export declare type FindOneStarterIncludeArgsOptional = {
  include?: StarterInclude | null
  where: StarterWhereUniqueInput
}
export declare type ExtractFindOneStarterSelectArgs<
  S extends undefined | boolean | FindOneStarterSelectArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends FindOneStarterSelectArgs
  ? S['select']
  : true
export declare type ExtractFindOneStarterIncludeArgs<
  S extends undefined | boolean | FindOneStarterIncludeArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends FindOneStarterIncludeArgs
  ? S['include']
  : true
/**
 * Starter findMany
 */
export declare type FindManyStarterArgs = {
  select?: StarterSelect | null
  include?: StarterInclude | null
  where?: StarterWhereInput | null
  orderBy?: StarterOrderByInput | null
  skip?: number | null
  after?: string | null
  before?: string | null
  first?: number | null
  last?: number | null
}
export declare type FindManyStarterArgsRequired = {
  select: StarterSelect
  include: StarterInclude
  where?: StarterWhereInput | null
  orderBy?: StarterOrderByInput | null
  skip?: number | null
  after?: string | null
  before?: string | null
  first?: number | null
  last?: number | null
}
export declare type FindManyStarterSelectArgs = {
  select: StarterSelect
  where?: StarterWhereInput | null
  orderBy?: StarterOrderByInput | null
  skip?: number | null
  after?: string | null
  before?: string | null
  first?: number | null
  last?: number | null
}
export declare type FindManyStarterSelectArgsOptional = {
  select?: StarterSelect | null
  where?: StarterWhereInput | null
  orderBy?: StarterOrderByInput | null
  skip?: number | null
  after?: string | null
  before?: string | null
  first?: number | null
  last?: number | null
}
export declare type FindManyStarterIncludeArgs = {
  include: StarterInclude
  where?: StarterWhereInput | null
  orderBy?: StarterOrderByInput | null
  skip?: number | null
  after?: string | null
  before?: string | null
  first?: number | null
  last?: number | null
}
export declare type FindManyStarterIncludeArgsOptional = {
  include?: StarterInclude | null
  where?: StarterWhereInput | null
  orderBy?: StarterOrderByInput | null
  skip?: number | null
  after?: string | null
  before?: string | null
  first?: number | null
  last?: number | null
}
export declare type ExtractFindManyStarterSelectArgs<
  S extends undefined | boolean | FindManyStarterSelectArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends FindManyStarterSelectArgs
  ? S['select']
  : true
export declare type ExtractFindManyStarterIncludeArgs<
  S extends undefined | boolean | FindManyStarterIncludeArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends FindManyStarterIncludeArgs
  ? S['include']
  : true
/**
 * Starter create
 */
export declare type StarterCreateArgs = {
  select?: StarterSelect | null
  include?: StarterInclude | null
  data: StarterCreateInput
}
export declare type StarterCreateArgsRequired = {
  select: StarterSelect
  include: StarterInclude
  data: StarterCreateInput
}
export declare type StarterSelectCreateArgs = {
  select: StarterSelect
  data: StarterCreateInput
}
export declare type StarterSelectCreateArgsOptional = {
  select?: StarterSelect | null
  data: StarterCreateInput
}
export declare type StarterIncludeCreateArgs = {
  include: StarterInclude
  data: StarterCreateInput
}
export declare type StarterIncludeCreateArgsOptional = {
  include?: StarterInclude | null
  data: StarterCreateInput
}
export declare type ExtractStarterSelectCreateArgs<
  S extends undefined | boolean | StarterSelectCreateArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterSelectCreateArgs
  ? S['select']
  : true
export declare type ExtractStarterIncludeCreateArgs<
  S extends undefined | boolean | StarterIncludeCreateArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterIncludeCreateArgs
  ? S['include']
  : true
/**
 * Starter update
 */
export declare type StarterUpdateArgs = {
  select?: StarterSelect | null
  include?: StarterInclude | null
  data: StarterUpdateInput
  where: StarterWhereUniqueInput
}
export declare type StarterUpdateArgsRequired = {
  select: StarterSelect
  include: StarterInclude
  data: StarterUpdateInput
  where: StarterWhereUniqueInput
}
export declare type StarterSelectUpdateArgs = {
  select: StarterSelect
  data: StarterUpdateInput
  where: StarterWhereUniqueInput
}
export declare type StarterSelectUpdateArgsOptional = {
  select?: StarterSelect | null
  data: StarterUpdateInput
  where: StarterWhereUniqueInput
}
export declare type StarterIncludeUpdateArgs = {
  include: StarterInclude
  data: StarterUpdateInput
  where: StarterWhereUniqueInput
}
export declare type StarterIncludeUpdateArgsOptional = {
  include?: StarterInclude | null
  data: StarterUpdateInput
  where: StarterWhereUniqueInput
}
export declare type ExtractStarterSelectUpdateArgs<
  S extends undefined | boolean | StarterSelectUpdateArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterSelectUpdateArgs
  ? S['select']
  : true
export declare type ExtractStarterIncludeUpdateArgs<
  S extends undefined | boolean | StarterIncludeUpdateArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterIncludeUpdateArgs
  ? S['include']
  : true
/**
 * Starter updateMany
 */
export declare type StarterUpdateManyArgs = {
  data: StarterUpdateManyMutationInput
  where?: StarterWhereInput | null
}
/**
 * Starter upsert
 */
export declare type StarterUpsertArgs = {
  select?: StarterSelect | null
  include?: StarterInclude | null
  where: StarterWhereUniqueInput
  create: StarterCreateInput
  update: StarterUpdateInput
}
export declare type StarterUpsertArgsRequired = {
  select: StarterSelect
  include: StarterInclude
  where: StarterWhereUniqueInput
  create: StarterCreateInput
  update: StarterUpdateInput
}
export declare type StarterSelectUpsertArgs = {
  select: StarterSelect
  where: StarterWhereUniqueInput
  create: StarterCreateInput
  update: StarterUpdateInput
}
export declare type StarterSelectUpsertArgsOptional = {
  select?: StarterSelect | null
  where: StarterWhereUniqueInput
  create: StarterCreateInput
  update: StarterUpdateInput
}
export declare type StarterIncludeUpsertArgs = {
  include: StarterInclude
  where: StarterWhereUniqueInput
  create: StarterCreateInput
  update: StarterUpdateInput
}
export declare type StarterIncludeUpsertArgsOptional = {
  include?: StarterInclude | null
  where: StarterWhereUniqueInput
  create: StarterCreateInput
  update: StarterUpdateInput
}
export declare type ExtractStarterSelectUpsertArgs<
  S extends undefined | boolean | StarterSelectUpsertArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterSelectUpsertArgs
  ? S['select']
  : true
export declare type ExtractStarterIncludeUpsertArgs<
  S extends undefined | boolean | StarterIncludeUpsertArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterIncludeUpsertArgs
  ? S['include']
  : true
/**
 * Starter delete
 */
export declare type StarterDeleteArgs = {
  select?: StarterSelect | null
  include?: StarterInclude | null
  where: StarterWhereUniqueInput
}
export declare type StarterDeleteArgsRequired = {
  select: StarterSelect
  include: StarterInclude
  where: StarterWhereUniqueInput
}
export declare type StarterSelectDeleteArgs = {
  select: StarterSelect
  where: StarterWhereUniqueInput
}
export declare type StarterSelectDeleteArgsOptional = {
  select?: StarterSelect | null
  where: StarterWhereUniqueInput
}
export declare type StarterIncludeDeleteArgs = {
  include: StarterInclude
  where: StarterWhereUniqueInput
}
export declare type StarterIncludeDeleteArgsOptional = {
  include?: StarterInclude | null
  where: StarterWhereUniqueInput
}
export declare type ExtractStarterSelectDeleteArgs<
  S extends undefined | boolean | StarterSelectDeleteArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterSelectDeleteArgs
  ? S['select']
  : true
export declare type ExtractStarterIncludeDeleteArgs<
  S extends undefined | boolean | StarterIncludeDeleteArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterIncludeDeleteArgs
  ? S['include']
  : true
/**
 * Starter deleteMany
 */
export declare type StarterDeleteManyArgs = {
  where?: StarterWhereInput | null
}
/**
 * Starter without action
 */
export declare type StarterArgs = {
  select?: StarterSelect | null
  include?: StarterInclude | null
}
export declare type StarterArgsRequired = {
  select: StarterSelect
  include: StarterInclude
}
export declare type StarterSelectArgs = {
  select: StarterSelect
}
export declare type StarterSelectArgsOptional = {
  select?: StarterSelect | null
}
export declare type StarterIncludeArgs = {
  include: StarterInclude
}
export declare type StarterIncludeArgsOptional = {
  include?: StarterInclude | null
}
export declare type ExtractStarterSelectArgs<
  S extends undefined | boolean | StarterSelectArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterSelectArgs
  ? S['select']
  : true
export declare type ExtractStarterIncludeArgs<
  S extends undefined | boolean | StarterIncludeArgsOptional
> = S extends undefined
  ? false
  : S extends boolean
  ? S
  : S extends StarterIncludeArgs
  ? S['include']
  : true
/**
 * Deep Input Types
 */
export declare type StarterWhereInput = {
  id?: string | StringFilter | null
  createdAt?: Date | string | DateTimeFilter | null
  updatedAt?: Date | string | DateTimeFilter | null
  repo?: string | StringFilter | null
  owner?: string | StringFilter | null
  path?: string | StringFilter | null
  ref?: string | StringFilter | null
  name?: string | StringFilter | null
  description?: string | NullableStringFilter | null | null
  AND?: Enumerable<StarterWhereInput> | null
  OR?: Enumerable<StarterWhereInput> | null
  NOT?: Enumerable<StarterWhereInput> | null
}
export declare type StarterWhereUniqueInput = {
  id?: string | null
}
export declare type StarterCreatedependenciesInput = {
  set?: Enumerable<string> | null
}
export declare type StarterCreateInput = {
  id?: string | null
  createdAt?: Date | string | null
  updatedAt?: Date | string | null
  repo: string
  owner: string
  path: string
  ref: string
  name: string
  description?: string | null
  dependencies?: StarterCreatedependenciesInput | null
}
export declare type StarterUpdatedependenciesInput = {
  set?: Enumerable<string> | null
}
export declare type StarterUpdateInput = {
  id?: string | null
  createdAt?: Date | string | null
  updatedAt?: Date | string | null
  repo?: string | null
  owner?: string | null
  path?: string | null
  ref?: string | null
  name?: string | null
  description?: string | null
  dependencies?: StarterUpdatedependenciesInput | null
}
export declare type StarterUpdateManyMutationInput = {
  id?: string | null
  createdAt?: Date | string | null
  updatedAt?: Date | string | null
  repo?: string | null
  owner?: string | null
  path?: string | null
  ref?: string | null
  name?: string | null
  description?: string | null
  dependencies?: StarterUpdatedependenciesInput | null
}
export declare type StringFilter = {
  equals?: string | null
  not?: string | StringFilter | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}
export declare type DateTimeFilter = {
  equals?: Date | string | null
  not?: Date | string | DateTimeFilter | null
  in?: Enumerable<Date | string> | null
  notIn?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
}
export declare type NullableStringFilter = {
  equals?: string | null | null
  not?: string | null | NullableStringFilter | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}
export declare type StarterOrderByInput = {
  id?: OrderByArg | null
  createdAt?: OrderByArg | null
  updatedAt?: OrderByArg | null
  repo?: OrderByArg | null
  owner?: OrderByArg | null
  path?: OrderByArg | null
  ref?: OrderByArg | null
  name?: OrderByArg | null
  description?: OrderByArg | null
}
/**
 * Batch Payload for updateMany & deleteMany
 */
export declare type BatchPayload = {
  count: number
}
/**
 * DMMF
 */
export declare const dmmf: DMMF.Document
export {}
